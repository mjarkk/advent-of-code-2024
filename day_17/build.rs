use std::fs;

const ADV: u8 = 0;
const BXL: u8 = 1;
const BST: u8 = 2;
const JNZ: u8 = 3;
const BXC: u8 = 4;
const OUT: u8 = 5;
const BDV: u8 = 6;
const CDV: u8 = 7;

fn main() {
    let puzzle = fs::read_to_string("./puzzle.txt").unwrap();

    let mut initial_a = 0;
    let mut initial_b = 0;
    let mut initial_c = 0;
    let mut program: Vec<u8> = Vec::new();

    for (idx, line) in puzzle.lines().enumerate() {
        match idx {
            0 => {
                initial_a = line.split(' ').last().unwrap().parse().unwrap();
            }
            1 => {
                initial_b = line.split(' ').last().unwrap().parse().unwrap();
            }
            2 => {
                initial_c = line.split(' ').last().unwrap().parse().unwrap();
            }
            4 => {
                for nr_str in line.split_once("Program: ").unwrap().1.split(',') {
                    program.push(nr_str.trim().parse().unwrap());
                }
            }
            _ => {}
        }
    }

    assert_eq!(
        program[program.len() - 2],
        JNZ,
        "program must end with JNZ instruction"
    );
    assert_eq!(program[program.len() - 1], 0, "last operand must be 0");

    let mut program_lines: Vec<String> = Vec::new();

    program_lines.push("// Auto generated by build.rs, do not modify".to_string());
    program_lines.push("".to_string());

    let program_str = program
        .iter()
        .map(|e| e.to_string())
        .collect::<Vec<String>>()
        .join(", ");
    program_lines.push(format!(
        "pub fn initial_program() -> [u8; {}] {}\n    [{}]\n{}",
        program.len(),
        '{',
        program_str,
        '}'
    ));
    program_lines.push("".to_string());
    program_lines.push(format!("pub const INITIAL_A: usize = {};", initial_a));
    program_lines.push(format!("pub const INITIAL_B: usize = {};", initial_b));
    program_lines.push(format!("pub const INITIAL_C: usize = {};", initial_c));
    program_lines.push("".to_string());
    program_lines.push("pub fn run(initial_a: usize, out: &mut [u8]) -> usize {".to_string());
    program_lines.push("    let mut register_a = initial_a;".to_string());
    program_lines.push("    #[allow(unused_assignments)]".to_string());
    program_lines.push("    let mut register_b = INITIAL_B;".to_string());
    program_lines.push("    #[allow(unused_assignments)]".to_string());
    program_lines.push("    let mut register_c = INITIAL_C;".to_string());
    program_lines.push("    let mut out_idx = 0;".to_string());
    program_lines.push("".to_string());
    program_lines.push("    loop {".to_string());

    for instruction_idx in 0..(program.len() / 2) - 1 {
        let instruction = program[instruction_idx * 2];
        let literal_operand = program[instruction_idx * 2 + 1];

        match instruction {
            ADV => {
                // The adv instruction (opcode 0) performs division. The numerator is the value in the A register.
                // The denominator is found by raising 2 to the power of the instruction's combo operand.
                // (So, an operand of 2 would divide A by 4 (2^2); an operand of 5 would divide A by 2^B.)
                // The result of the division operation is truncated to an integer and then written to the A register.

                program_lines.push(format!(
                    "        register_a /= 2usize.pow({});",
                    combo_operand(literal_operand, "u32")
                ));
            }
            BXL => {
                // The bxl instruction (opcode 1) calculates the bitwise XOR of register B and
                // the instruction's literal operand, then stores the result in register B.

                program_lines.push(format!("        register_b ^= {};", literal_operand));
            }
            BST => {
                // The bst instruction (opcode 2) calculates the value of its combo operand modulo 8
                // (thereby keeping only its lowest 3 bits), then writes that value to the B register.

                program_lines.push(format!(
                    "        register_b = {} % 8;",
                    combo_operand(literal_operand, "usize")
                ));
            }
            JNZ => {
                // The jnz instruction (opcode 3) does nothing if the A register is 0.
                // However, if the A register is not zero, it jumps by setting the instruction pointer to the value of its literal operand;
                // if this instruction jumps, the instruction pointer is not increased by 2 after this instruction.
                //
                // Note that in all examples i've seen there is always a jump to the start of the program here
                // So i'll asume that's static to make things simpler

                panic!("JNZ instruction found, this one is already handled by default");
            }
            BXC => {
                // The bxc instruction (opcode 4) calculates the bitwise XOR of register B and register C,
                // then stores the result in register B. (For legacy reasons, this instruction reads an operand but ignores it.)

                program_lines.push("        register_b ^= register_c;".to_string());
            }
            OUT => {
                // The out instruction (opcode 5) calculates the value of its combo operand modulo 8,
                // then outputs that value. (If a program outputs multiple values, they are separated by commas.)

                program_lines.push(format!(
                    "        out[out_idx] = ({} % 8) as u8;",
                    combo_operand(literal_operand, "usize")
                ));
                program_lines.push("        out_idx += 1;".to_string())
            }
            BDV => {
                // The bdv instruction (opcode 6) works exactly like the adv instruction except
                // that the result is stored in the B register. (The numerator is still read from the A register.)

                program_lines.push(format!(
                    "    register_b = register_a / 2usize.pow({});",
                    combo_operand(literal_operand, "u32")
                ));
            }
            CDV => {
                // The cdv instruction (opcode 7) works exactly like the adv instruction except
                // that the result is stored in the C register. (The numerator is still read from the A register.)

                program_lines.push(format!(
                    "        register_c = register_a / 2usize.pow({});",
                    combo_operand(literal_operand, "u32")
                ));
            }
            _ => panic!("Unknown instruction: {}", instruction),
        }
    }

    program_lines.push("        if register_a == 0 {".to_string());
    program_lines.push("            break;".to_string());
    program_lines.push("        }".to_string());
    program_lines.push("    }".to_string());
    program_lines.push("".to_string());
    program_lines.push("    out_idx".to_string());
    program_lines.push("}".to_string());

    fs::write("./src/program.rs", program_lines.join("\n")).unwrap();
}

fn combo_operand(oprand: u8, number_type: &str) -> String {
    match oprand {
        0 | 1 | 2 | 3 => oprand.to_string() + number_type,
        4 if number_type != "usize" => format!("register_a as {}", number_type),
        5 if number_type != "usize" => format!("register_b as {}", number_type),
        6 if number_type != "usize" => format!("register_c as {}", number_type),
        4 => "register_a".to_string(),
        5 => "register_b".to_string(),
        6 => "register_c".to_string(),
        _ => panic!("Unknown combo operand selector {}", oprand),
    }
}
